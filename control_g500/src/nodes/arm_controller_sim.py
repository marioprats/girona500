#! /usr/bin/env python

#  This node simulate the controller for the new arm
#  Created on: 28/03/2012
#  Author: arnau

# ROS imports
import roslib 
roslib.load_manifest('control_g500')
import rospy

#import messages
from sensor_msgs.msg import JointState



class ArmControllerSim:
    #This have to go to the config file ?
    #NUMBER_JOINTS = 3
    def __init__(self, name):
        self.name = name
        self.getConfig()
        #Create publisher
        self.pub = rospy.Publisher("/uwsim/joint_state_command", JointState)
        #Create subscriber
        rospy.Subscriber("/uwsim/joint_state", JointState, self.updateJointState)
        rospy.Subscriber("/control_g500/joint_state", JointState, self.updateJointStateKeyboard)

        #Crear Timer
        rospy.Timer(rospy.Duration(0.1), self.pubJointData)

        #save the data from the keyboard
        self.joint_data_command = JointState()
        #save the data from the stat in the simulator
        self.joint_data_state = JointState()

        for i in xrange(4):
            self.joint_data_command.position.append(0.0)
            self.joint_data_command.velocity.append(0.0)
            self.joint_data_command.effort.append(0.0)
            self.joint_data_state.position.append(0.0)
            self.joint_data_state.velocity.append(0.0)
            self.joint_data_state.effort.append(0.0)

        rospy.loginfo("%s, initialized", self.name)

    def getConfig(self):
        #This is redundant I not sure where have to be cheked
        # may be is optimal to check in booth parts or if the message
        # is not generated by a keyboard

        #There are not needed the maximal position of each joint ?
        #The maximal positions are safer to reach ?
        if rospy.has_param("joint/min_arm_v"):
            self.min_arm_v = rospy.get_param('joint/min_arm_v')
        else:
            rospy.logfatal("joint/min_arm_v param not found")
       	
        if rospy.has_param("joint/max_arm_v") :
            self.max_arm_v = rospy.get_param('joint/max_arm_v')
        else:
            rospy.logfatal("joint/max_arm_v param not found")

        if rospy.has_param("joint/min_hand_v"):
            self.min_hand_v = rospy.get_param('joint/min_hand_v')
        else:
            rospy.logfatal("joint/min_hand_v param not found")
       	
        if rospy.has_param("joint/max_hand_v") :
            self.max_hand_v = rospy.get_param('joint/max_hand_v')
        else:
            rospy.logfatal("joint/max_hand_v param not found")

        if rospy.has_param("joint/min_support_v"):
            self.min_support_v = rospy.get_param('joint/min_support_v')
        else:
            rospy.logfatal("joint/min_support_v param not found")
       	
        if rospy.has_param("joint/max_support_v") :
            self.max_support_v = rospy.get_param('joint/max_support_v')
        else:
            rospy.logfatal("joint/max_support_v param not found")


    # This function is called every time we recive a message from keyboard
    # with a new state
    def updateJointStateKeyboard(self, joint_data_command):
        self.joint_data_command.position[0] = joint_data_command.position[0]
        self.joint_data_command.position[1] = joint_data_command.position[1]
        self.joint_data_command.position[2] = joint_data_command.position[2]
        self.joint_data_command.velocity[0] = joint_data_command.velocity[0]
        self.joint_data_command.velocity[1] = joint_data_command.velocity[1]
        self.joint_data_command.velocity[2] = joint_data_command.velocity[2]
    # This function is called every time we recive a message from simulator


    def updateJointState(self,joint_data_state) :
        self.joint_data_state = joint_data_state
       # print self.joint_data_state


    #This function is called every each period. To avoid saturet the controler or serial port
    # In this case we will increment the position really slow.
    def pubJointData(self, event ):
        # here is needed to do a PID o some kind of control
        # it will be really defined by hoy it moves
        joint_msg = JointState()
        #joint_msg = self.joint_data_state
        
        joint_msg.header.stamp = rospy.Time.now()
        for i in xrange(4):
            joint_msg.position.append(self.joint_data_state.position[i] + self.joint_data_command.velocity[i]) 
    

        if(joint_msg.position[0] > self.max_arm_v):
            joint_msg.position[0] = self.max_arm_v
        elif(joint_msg.position[0] < self.min_arm_v):
            joint_msg.position[0] = self.min_arm_v
		 
        if(joint_msg.position[1] > self.max_hand_v) :
            joint_msg.position[1] = self.max_hand_v
        elif(joint_msg.position[1] < self.min_hand_v):
            joint_msg.position[1] = self.min_hand_v
				
        if(joint_msg.position[2] > self.max_support_v) :
            joint_msg.position[2] = self.max_support_v
        elif(joint_msg.position[2] < self.min_support_v) :
            joint_msg.position[2] = self.min_support_v
    
        self.pub.publish(joint_msg)
        

if __name__ == '__main__':
    try:
        rospy.init_node('arm_controller_sim')
        joystick = ArmControllerSim(rospy.get_name())
        rospy.spin() 
    except rospy.ROSInterruptException: pass
